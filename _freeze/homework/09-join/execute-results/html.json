{
  "hash": "36f515617bf432a7b0a412ca4e2f3810",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: 'Homework 9: Joining Data'\ndate: '2024-04-08'\nexecute-dir: ../homework-repos/09-join/\nengine: knitr\nauthor: Homework\ncategories:\n- Week10\n- HW\n---\n\n\nNote: This assignment must be submitted in github classroom.\n\n\n\n---\ntitle: \"Homework 8: Joins and Summaries\"\nauthor: \"Your Name\"\nformat: html\ncategories: hw\n---\n\nThis week, you'll be using table joins to solve a murder mystery.\n\n# Instructions\nNorthwestern University's Knight lab created a SQL murder mystery to help users sharpen their database skills by solving the crime that happened at SQL city. There are tables with different pieces of information - social media checkins, people, drivers licenses, crime scene reports, police interviews, and more. \n\n![Database schema](https://mystery.knightlab.com/schema.png)\n\nPick R or python, and solve the murder mystery, showing **all of your work in this document**. \n\nYour solution must be **reproducible** -- that is, you should use dplyr verbs, table joins, etc. to solve the mystery, rather than just looking through the tables yourselves. Your code must execute properly and stand alone.\n\n**For 5 bonus points, when you're finished in one language, write equivalent code in the other language to solve the problem.**\n\nWhen you are finished with the assignment: \n\n1. Save the file as `index.qmd` and compile it, making sure all of your code runs.\n2. If applicable, enter the name of the guilty party on Canvas to submit the homework assignment.\n\nNote that you should be able to do this entire mystery with only about 3 filter statements (including the one below to get you started). \n\nTry to focus on using **filtering joins** instead of filter statements where possible in this assignment.\n\n# Setup\n\n## R\n\n::: {.cell hash='09-join_cache/html/db-setup-r_6aa60133f5a841ce96bea07cb4e438fd'}\n\n```{.r .cell-code}\n# you can do the assignment using the database, if you want, \n# or you can use the code below to read in each table separately.\nlibrary(RSQLite)\nlibrary(DBI)\n# Your database connection code goes here. Store the connection as con \ncon <- dbConnect(RSQLite::SQLite(), \"sql-murder-mystery.db\")\n# close the connection when you're done\ndbDisconnect(con)\n```\n:::\n\n::: {.cell hash='09-join_cache/html/table-setup-r_bc5b4b4b0503713f6d7da49406f973d0'}\n\n```{.r .cell-code}\n# This loads all of the tables into R data frame objects. \n# You can also just use the database connection above.\n# You don't need to understand what this code does to run it :)\nif (!\"purrr\" %in% installed.packages()) {\n  install.packages(\"purrr\")\n}\n# Load all tables from CSV\ntable_names <- c(\"crime_scene_report\", \n                 \"drivers_license\", \n                 \"facebook_event_checkin\",\n                 \"get_fit_now_check_in\", \n                 \"get_fit_now_member\", \n                 \"income\", \n                 \"interview\",\n                 \"person\")\nurl_base <- \"https://raw.githubusercontent.com/srvanderplas/datasets/main/raw/sql-murder/\"\n# For each table name, read the tables in and store them as the name of the table\npurrr::walk(table_names, function(x) {\n  assign(x, readr::read_csv(paste0(url_base, x, \".csv\")), envir = .GlobalEnv)\n})\n```\n:::\n\n\n\n## Python\n\n::: {.cell hash='09-join_cache/html/table-setup-py_1cf166632ff380c6377fed3af4729e0c'}\n\n```{.python .cell-code}\nimport pandas as pd\nimport sqlite3\n# Read sqlite query results into a pandas DataFrame\ncon = sqlite3.connect(\"sql-murder-mystery.db\")\ncrime_scene_report = pd.read_sql_query(\"SELECT * from crime_scene_report\", con)\ndrivers_license = pd.read_sql_query(\"SELECT * from drivers_license\", con)\nfacebook_event_checkin = pd.read_sql_query(\"SELECT * from facebook_event_checkin\", con)\nget_fit_now_check_in = pd.read_sql_query(\"SELECT * from get_fit_now_check_in\", con)\nget_fit_now_member = pd.read_sql_query(\"SELECT * from get_fit_now_member\", con)\nincome = pd.read_sql_query(\"SELECT * from income\", con)\ninterview = pd.read_sql_query(\"SELECT * from interview\", con)\nperson = pd.read_sql_query(\"SELECT * from person\", con)\n# Verify that result of SQL query is stored in the dataframe\nprint(crime_scene_report.head())\ncon.close()\n```\n:::\n\n\n## Getting Started \n\nTo get you started, I'll set you up in the right place. \n\n\n> A crime has taken place and the detective needs your help. The detective gave you the crime scene report, but you somehow lost it. You vaguely remember that the crime was a *murder* that occurred sometime on *Jan.15, 2018* and that it took place in *SQL City*. Start by retrieving the corresponding crime scene report from the police departmentâ€™s database.\n\n::: {.cell hash='09-join_cache/html/unnamed-chunk-2_a3624ba1b3a070638292d56eab7697a8'}\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'dplyr'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(tidyr)\n\ncrime_of_interest <- crime_scene_report %>%\n  filter(date == \"20180115\", city == \"SQL City\", type == \"murder\")\ncrime_of_interest$description\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Security footage shows that there were 2 witnesses. The first witness lives at the last house on \\\"Northwestern Dr\\\". The second witness, named Annabel, lives somewhere on \\\"Franklin Ave\\\".\"\n```\n\n\n:::\n:::\n\n\n# Solution\n\nDocument each productive step of your investigation here.\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}